#Saccade detection with the gaze generated by Pylids
import matplotlib.pyplot as plt 
from eye_head_class import eyeHead
import numpy as np
from scipy.signal import savgol_filter
import seaborn as sns
import matplotlib.patches as patches
from scipy import stats
"""
x = 67.5"
y = 43"
z = 29.25"
horizontal FOV = 125 deg
vertical FOV = 110 deg
Pupil Fs -> 120 Hz
T265 Fs -> 200
"""
class saccadeDetect(eyeHead):
    def __init__(self):
        super().__init__()
        print('Instantiate saccadeDetect object')
        self.fov_horiz = 125 #deg 
        self.fov_vertical = 110 #deg
        self.pupil_fs = 1/120
    def get_gaze(self):
        print(self.input_folder)
        self.eye_utils()
        self.calibration_markers_find()
        self.load_pylids()
        self.calculate_calibration()
        self.validation_markers_calc()
        self.gaze = self.gaze_calc()
    def convert_norm_pos_to_degrees(self):
        """
        Should I do a mean offset?
        """
        self.gaze['left']['norm_pos'][:,0] = self.gaze['left']['norm_pos'][:,0] * self.fov_horiz
        self.gaze['right']['norm_pos'][:,0] = self.gaze['right']['norm_pos'][:,0] * self.fov_horiz
        self.gaze['left']['norm_pos'][:,1] = self.gaze['left']['norm_pos'][:,1] * self.fov_vertical
        self.gaze['right']['norm_pos'][:,1] = self.gaze['right']['norm_pos'][:,1] * self.fov_vertical
        # plt.scatter(self.gaze['left']['norm_pos'][:,0],self.gaze['left']['norm_pos'][:,1],label='left eye')
        # plt.scatter(self.gaze['right']['norm_pos'][:,0],self.gaze['right']['norm_pos'][:,1],label='right eye')
        # plt.legend()
        # plt.show()
    def filter_data(self):
        windows = 91
        self.gaze['left']['norm_pos'][:,0] = savgol_filter(self.gaze['left']['norm_pos'][:,0],
                                                           polyorder=2,window_length=windows)
        self.gaze['right']['norm_pos'][:,0] = savgol_filter(self.gaze['right']['norm_pos'][:,0],
                                                           polyorder=2,window_length=windows)
        self.gaze['left']['norm_pos'][:,1] = savgol_filter(self.gaze['left']['norm_pos'][:,1],
                                                           polyorder=2,window_length=windows)
        self.gaze['right']['norm_pos'][:,1] = savgol_filter(self.gaze['right']['norm_pos'][:,1],
                                                           polyorder=2,window_length=windows)
        # plt.scatter(self.gaze['left']['norm_pos'][:,0],self.gaze['left']['norm_pos'][:,1],label='left eye')
        # plt.scatter(self.gaze['right']['norm_pos'][:,0],self.gaze['right']['norm_pos'][:,1],label='right eye')
        # plt.legend()
        # plt.show()
    def visualize_gaze(self):
        #Get mean and std
        for i in ['left','right']:
            x_mean = np.mean(self.gaze[i]['norm_pos'][:,0])
            y_mean = np.mean(self.gaze[i]['norm_pos'][:,1])
            x_std = np.std(self.gaze[i]['norm_pos'][:,0])
            y_std = np.std(self.gaze[i]['norm_pos'][:,1])
            # Filter out the points outside the 3 standard deviation range
            x_data = self.gaze[i]['norm_pos'][:,0]
            y_data = self.gaze[i]['norm_pos'][:,1]
            mask = (x_data > x_mean - 3 * x_std) & (x_data < x_mean + 3 * x_std) & \
                (y_data > y_mean - 3 * y_std) & (y_data < y_mean + 3 * y_std)
            x_filtered = x_data[mask]
            y_filtered = y_data[mask]
            #Calculate the 95% CI elipse
            mean_x = np.mean(x_filtered)
            mean_y = np.mean(y_filtered)
            covariance_matrix = np.cov(x_filtered, y_filtered)
            eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)
            sorted_indices = np.argsort(eigenvalues)[::-1]
            eigenvalues = eigenvalues[sorted_indices]
            eigenvectors = eigenvectors[:, sorted_indices]
            angle = np.arctan2(eigenvectors[1,0], eigenvectors[0,0])
            width = 2 * np.sqrt(eigenvalues[0]) * stats.chi2.ppf(0.95, df=2) ** 0.5
            height = 2 * np.sqrt(eigenvalues[1]) * stats.chi2.ppf(0.95, df=2) ** 0.5
            t = np.linspace(0, 2*np.pi, 100) #it has to be a circle, that's an oval
            ellipse_x = mean_x + width/2 * np.cos(t) * np.cos(angle) - height/2 * np.sin(t) * np.sin(angle)
            ellipse_y = mean_y + width/2 * np.cos(t) * np.sin(angle) + height/2 * np.sin(t) * np.cos(angle)

            # scatter plot
            fig, ax = plt.subplots()
            ax.scatter(x_filtered, y_filtered, alpha=0.2, s=1, label=f"{i} gaze")
            ax.plot(ellipse_x, ellipse_y, color='red',label='95% CI')
            ax.set_aspect('equal')
            ax.set_xlabel('GAZE X (degrees)')
            ax.set_ylabel('GAZE Y (degrees)')
            ax.set_title(f'{i.capitalize()} Eye Gaze with 95% CI Ellipse. Data within 2 std')
            plt.legend()
            plt.savefig(f'{i}_eye.png',dpi=350)
            plt.close()
    def calc_saccade_velocity(self,array,timestamps):
        """
        saccade velocity thresholds onset/offset 80<velocity<900
        saccadic acceleration thresholds 5000<accel<50000
        saccadic duration threshold 20 to 50 milliseconds for small saccades and up to around 100
        """
        saccade_velocity = abs(np.diff(array) / np.diff(timestamps))
        # saccade_accel = abs(np.diff(saccade_velocity) / self.pupil_fs)
        # plt.figure()
        # plt.plot(saccade_velocity)
        # plt.show()
        start_points = []
        end_points = []
        above_80 = False
        for i, value in enumerate(saccade_velocity):
            if (value > 100 and not above_80):
                # if saccade_accel[i-1] > 5000:
                    above_80 = True
                    start = i
            elif value < 100 and above_80:
                above_80 = False
                end = i
                time_diff = ((timestamps[end] - timestamps[start])) * 1000 #ms VERY CRUDE WAY OF DOING THIS
                if time_diff > 20 and time_diff < 100:
                    start_points.append(start)
                    end_points.append(i)
        if above_80:
            end_points.append(i)
        mean_saccade_vel = []
        peak_saccadel_vel = []
        plt.plot(timestamps,array,marker='o',color='tab:blue')
        for start, end in zip(start_points, end_points):
            plt.plot(timestamps[start:end], array[start:end],marker='o', color='tab:orange')
            # plt.fill_between(timestamps[start:end], saccade_velocity[start:end], color='green',alpha=0.3)
        plt.ylabel('Elevation (degrees)')
        plt.legend(['Right Eye Gaze Elevation','Saccade'])
        plt.xlabel('Timestamp')
        plt.show()
        # plt.scatter(timestamps[start_points],saccade_velocity[start_points],marker='*',color='green')
        # plt.scatter(timestamps[end_points],saccade_velocity[end_points],marker='*',color='green')
        # plt.show()
        for i in range(len(end_points)):
            temp_vel = saccade_velocity[start_points[i]:end_points[i]]
            if len(temp_vel) > 0:
                peak_saccadel_vel.append(np.max(temp_vel))
                mean_saccade_vel.append(np.mean(temp_vel))
            
    def saccade_thresholding(self):
        """
        Use onset offset saccade thresholding and plot the method
        """
        horizontal_FOV =  125 / 2
        vertical_FOV = 110 / 2
        self.gaze['left']['norm_pos'][:,0] = self.gaze['left']['norm_pos'][:,0] - horizontal_FOV 
        self.gaze['left']['norm_pos'][:,1] = self.gaze['left']['norm_pos'][:,1] - vertical_FOV

        self.gaze['right']['norm_pos'][:,0] = self.gaze['right']['norm_pos'][:,0] - horizontal_FOV 
        self.gaze['right']['norm_pos'][:,1] = self.gaze['right']['norm_pos'][:,1] - vertical_FOV
        self.calc_saccade_velocity(self.gaze['right']['norm_pos'][:,1],self.gaze['right']['timestamp'])
        # plt.figure()
        # plt.plot(self.gaze['right']['norm_pos'][:,1])
        # plt.hist(self.gaze['left']['norm_pos'][:,0],label='az',alpha=0.6,bins=200)
        # plt.hist(self.gaze['left']['norm_pos'][:,1],label='el',alpha=0.6,bins=200)
        # plt.legend()
        # plt.show()
  
    def run_analysis(self):
        self.get_gaze()
        self.convert_norm_pos_to_degrees()
        self.filter_data()
        self.visualize_gaze()
        self.saccade_thresholding()

def main():
    saccadeDetect().run_analysis()
if __name__ == "__main__":
    main()