#Saccade detection with the gaze generated by Pylids
import matplotlib.pyplot as plt 
from eye_head_class import eyeHead
import numpy as np
from scipy.signal import savgol_filter
import seaborn as sns
import matplotlib.patches as patches
from scipy import stats
"""
x = 67.5"
y = 43"
z = 29.25"
horizontal FOV = 125 deg
vertical FOV = 110 deg
Pupil Fs -> 120 Hz
T265 Fs -> 200
"""
class saccadeDetect(eyeHead):
    def __init__(self):
        super().__init__()
        print('Instantiate saccadeDetect object')
        self.fov_horiz = 125 #deg 
        self.fov_vertical = 110 #deg
    def get_gaze(self):
        print(self.input_folder)
        self.eye_utils()
        self.calibration_markers_find()
        self.load_pylids()
        self.calculate_calibration()
        self.validation_markers_calc()
        self.gaze = self.gaze_calc()
    def convert_norm_pos_to_degrees(self):
        """
        Should I do a mean offset?
        """
        self.gaze['left']['norm_pos'][:,0] = self.gaze['left']['norm_pos'][:,0] * self.fov_horiz
        self.gaze['right']['norm_pos'][:,0] = self.gaze['right']['norm_pos'][:,0] * self.fov_horiz
        self.gaze['left']['norm_pos'][:,1] = self.gaze['left']['norm_pos'][:,1] * self.fov_vertical
        self.gaze['right']['norm_pos'][:,1] = self.gaze['right']['norm_pos'][:,1] * self.fov_vertical
        # plt.scatter(self.gaze['left']['norm_pos'][:,0],self.gaze['left']['norm_pos'][:,1],label='left eye')
        # plt.scatter(self.gaze['right']['norm_pos'][:,0],self.gaze['right']['norm_pos'][:,1],label='right eye')
        # plt.legend()
        # plt.show()
    def filter_data(self):
        windows = 91
        self.gaze['left']['norm_pos'][:,0] = savgol_filter(self.gaze['left']['norm_pos'][:,0],
                                                           polyorder=2,window_length=windows)
        self.gaze['right']['norm_pos'][:,0] = savgol_filter(self.gaze['right']['norm_pos'][:,0],
                                                           polyorder=2,window_length=windows)
        self.gaze['left']['norm_pos'][:,1] = savgol_filter(self.gaze['left']['norm_pos'][:,1],
                                                           polyorder=2,window_length=windows)
        self.gaze['right']['norm_pos'][:,1] = savgol_filter(self.gaze['right']['norm_pos'][:,1],
                                                           polyorder=2,window_length=windows)
        # plt.scatter(self.gaze['left']['norm_pos'][:,0],self.gaze['left']['norm_pos'][:,1],label='left eye')
        # plt.scatter(self.gaze['right']['norm_pos'][:,0],self.gaze['right']['norm_pos'][:,1],label='right eye')
        # plt.legend()
        # plt.show()
    def visualize_gaze(self):
        #Get mean and std
        for i in ['left','right']:
            x_mean = np.mean(self.gaze[i]['norm_pos'][:,0])
            y_mean = np.mean(self.gaze[i]['norm_pos'][:,1])
            x_std = np.std(self.gaze[i]['norm_pos'][:,0])
            y_std = np.std(self.gaze[i]['norm_pos'][:,1])
            # Filter out the points outside the 3 standard deviation range
            x_data = self.gaze[i]['norm_pos'][:,0]
            y_data = self.gaze[i]['norm_pos'][:,1]
            mask = (x_data > x_mean - 3 * x_std) & (x_data < x_mean + 3 * x_std) & \
                (y_data > y_mean - 3 * y_std) & (y_data < y_mean + 3 * y_std)
            x_filtered = x_data[mask]
            y_filtered = y_data[mask]
            #Calculate the 95% CI elipse
            mean_x = np.mean(x_filtered)
            mean_y = np.mean(y_filtered)
            covariance_matrix = np.cov(x_filtered, y_filtered)
            eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)
            sorted_indices = np.argsort(eigenvalues)[::-1]
            eigenvalues = eigenvalues[sorted_indices]
            eigenvectors = eigenvectors[:, sorted_indices]
            angle = np.arctan2(eigenvectors[1,0], eigenvectors[0,0])
            width = 2 * np.sqrt(eigenvalues[0]) * stats.chi2.ppf(0.95, df=2) ** 0.5
            height = 2 * np.sqrt(eigenvalues[1]) * stats.chi2.ppf(0.95, df=2) ** 0.5
            t = np.linspace(0, 2*np.pi, 100) #it has to be a circle, that's an oval
            ellipse_x = mean_x + width/2 * np.cos(t) * np.cos(angle) - height/2 * np.sin(t) * np.sin(angle)
            ellipse_y = mean_y + width/2 * np.cos(t) * np.sin(angle) + height/2 * np.sin(t) * np.cos(angle)

            # scatter plot
            fig, ax = plt.subplots()
            ax.scatter(x_filtered, y_filtered, alpha=0.2, s=1, label=f"{i} gaze")
            ax.plot(ellipse_x, ellipse_y, color='red',label='95% CI')
            ax.set_aspect('equal')
            ax.set_xlabel('GAZE X (degrees)')
            ax.set_ylabel('GAZE Y (degrees)')
            ax.set_title(f'{i.capitalize()} Eye Gaze with 95% CI Ellipse. Data within 2 std')
            plt.legend()
            plt.savefig(f'{i}_eye.png',dpi=350)

    def saccade_thresholding(self):
        """
        Use onset offset saccade thresholding and plot the method
        """
        pass  
    def run_analysis(self):
        self.get_gaze()
        self.convert_norm_pos_to_degrees()
        self.filter_data()
        self.visualize_gaze()
        self.saccade_thresholding()

def main():
    saccadeDetect().run_analysis()
if __name__ == "__main__":
    main()